# What's Redux and Why use it?
* Now we know what ` Redux ` is and why we use it. It simply **abstracts** ` state ` **management** as well as **communication between components**. In other words it *kills* the **dependency** of **components** on each other and provides a better solution to pass data and manipulate ` state ` easily.
* Now the question is how does ` Redux ` achieve that?
    * ` Redux ` provides all **components** in our application the ability to ` dispatch ` ` actions ` whenever they want to change the ` state ` of the application. No matter where you are in and where your intended update in, all you need to do is to ` dispatch ` an ` action ` and let ` Redux ` does this for you.
    * Now we need something to **respond** to these ` actions ` by **handling** ` state ` change for us. Here comes ` Reducer ` to the scene. ` Reducer ` is a method that we define to **handle** ` actions ` ` dispatched ` by ` components `. ` Reducer ` should identify the ` action `, respond to it by changing ` state ` in an **immutable**(recommended) way that reflects this ` action ` and let ` Redux ` does what's needed after this ` state ` change. Note that in an **immutable** way means that you **copy** the old ` state `, update this copy and then return it with leaving the **original** ` state ` intact.
    * Now as you might guess we need something to **keep** track of different versions of ` state ` as well as **notify** any ` Component ` interested in a specific ` action `. Here comes ` Store ` to do that for us. **Components** ` subscribe ` to ` Store ` to be notified when they need to **update** their ` state ` as a result of a ` state ` change.  
    * Note that we can have **multiple** ` Reducers ` in our application. However, we have only one ` Store ` that all interested ` components ` ` subscribe ` to.        
